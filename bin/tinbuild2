#!/usr/bin/env bash
#
#    Copyright (C) 2011 Norbert Thiebaud
#    License: GPLv3
#

BIN_DIR=$(dirname "$0")

PAUSE_SECOND=$((15*60))
PUSH_NIGHTLIES=0
SEND_MAIL="all"
LOCK=1
NICE=
PROFILE_NAME=
PRIME_BUILD=0
V=
CHECK=0


# load the internal functions. note that
# tinderbuild_internals_<uname>.sh is sourced at the tail
# end of tinbuild_internals.sh. this allow you do do
# platform specific stuff.
# after the platform specific internal script (if present) is
# sourced, then tinbuild_phases.sh is sourced
# this is where the standard build cycle unit functions are implemented
# you can redefine these function in ~/.tinbuild/phases/<profile>.sh
# which is sourced, if it exist, at the end of tinderbuild_phases.sh
#
# The build cycle, invoked in this script with do_build, consist
# of 5 phases that are processed in this order: autogen, clean, make, test, push
# eeach phase execution try to invoke pre_<phase>, do_<phase> and post_<pahse>
# in this order, if the respective bash function are defined.
#
# In order to implement a specific step, pre_build for instance, you need
# to implement a function pre_build() in ~/.tinbuild/config/phases/<profile>.sh
# these function take no parameter at all, tough you can use any global variable
# (the one in which a name in UPPERCASE in this script. all effort will be made to
# maintain the existance of these variable
# every step should also condition the entiere execution of the step by testing that
# the variable $retval is equal to 0. if not the step must return $retval immediately
# the step can do which ever actions that are deemded necessary..
# the step must collect the relevant messages in tb_${B}_<step_name>.log
# In case of error the step must set the error condition in the following manner
#  report_log=tb_${B}_<step_name>.log
#  report_msgs="<step_name> failed - error is:"
#  retval=1
# with the convention that do_xxx steps are shortenen to just xxx in the above filenames
# and messages when substitution <step>.
#
# For example this is how do_make is implemented in tinderbuild_phases.sh
#
# do_make()
# {
#	 if [ "${retval}" = "0" ] ; then
#		 if ! $NICE ${MAKE?} >tb_${B}_build.log 2>&1 ; then
#             report_log=tb_${B}_build.log
#             report_msgs="build failed - error is:"
#			 retval=1
#		 fi
#	 fi
# }




source ${BIN_DIR?}/tinbuild_internals.sh

display_setup_instruction()
{
cat << EOF
In order to use $0 you need to:

* create a directory ~/.tinbuild/config
* create a file ~/.tinderbuild/config/<profile_name>
    where <profile_name> is the argument you pased to the mandatory parameter -p
    that <profile_name> is sourced and define at least:
       SMTPHOST=<name of you smtp host to send email>
       SMTPUSER=<user name to connect to you smtp host>
       SMTPPW=<password to connect to your smtp host>
       TINDER_NAME=<name of you tinderbox>
       OWNER=<valid email address where people you spam with tinbuild error can contact you>

EOF
}

usage()
{
cat << EOF
Usage $0 [options] -p <profile_name>
Options:
   -h           print help
   -c           sanity check (verify that tou configuration is sane and send a test email)
   -i           run with ionice -c3, can be combined with -n
   -m [all,tb,owner,none]
                tb=mail progress to the tinderbox,
                all=tb + mail errors to the committer, general errors to the owner.
                owner= tb + any other mail to the owner only
                debug=any mail (progress or error) is sent to the owner
                none=no mail
                Default=all"
   -n           run with nice, can be combined with -i
   -p <profile> profile to use.
   -r <bandwidth> push the build nightly at a rate limited by <badnwidth> (in kB/s)
   -v           verbose. print more progress messages
   -w           specify minimum wait between build attempt
   -z           bootstrap/prime the tinbuild

EOF
}

load_profile()
{
    local p=$1
    local rc=0

    if [ -z "$p" ] ; then
        echo "a profile is needed to run, see help" >&2
        exit 1
    else
        if [ ! -f $HOME/.tinbuild/config/${p}.cfg ] ; then
            echo "$HOME/.tinbuild/config/${p}.cfg can't be accessed" >&2
            exit 1
        else
            source "$HOME/.tinbuild/config/${p}.cfg"
            # add check to make sure that thing are setup correctly
            if [ -f "$HOME/.tinbuild/phases/${p}.sh" ] ; then
                source "$HOME/.tinbuild/phases/${p}.sh"
            fi
        fi
    fi
}

sanity_check()
{
    g=$(git rev-parse --git-dir 2> /dev/null)
    if [ "$g" != ".git" ] ; then
        echo "Error: The current working directory must be the root git repo"
        exit 1
    fi

    if [ ! -f configure.in ] ; then
        echo "Error: The current working directory must be the root git repo"
        exit 1
    fi

    if [ ! -d $HOME/.tinbuild ] ; then
        echo "Error: the directory $HOME/.tinbuild does mot exist" >&2
        display_setup_instruction
        exit 1
    fi
    if [ ! -d $HOME/.tinbuild/config ] ; then
        echo "Error: the directory $HOME/.tinbuild/config does mot exist" >&2
        display_setup_instruction
        exit 1
    fi
    if [ ! -f $HOME/.tinbuild/config/${PROFILE_NAME?}.cfg ] ; then
        echo "Error: the file $HOME/.tinbuild/config/${PROFILE_NAME?} does mot exist" >&2
        display_setup_instruction
        exit 1
    fi
    if [ ! -f $HOME/.tinbuild/autogen/${PROFILE_NAME?}.autogen ] ; then
        if [ ! -f autogen.lastrun ] ; then
            echo "Error: Neither $HOME/.tinbuild/autogen/${PROFILE_NAME?}.autogen or autogen.lastrun exist" >&2
        else
            echo "Warning: the file $HOME/.tinbuild/autogen/${PROFILE_NAME?}.autogen does mot exist. Will use autogen.lastrun :" >&2
            cat autogen.lastrun
        fi
        exit 1
    fi

    source $HOME/.tinbuild/config/${PROFILE_NAME?}.cfg || (echo "Error sourcing $HOME/.tinbuild/config/${PROFILE_NAME?}.cfg" ; exit 1)
    rc = 0

    if [ -z "${SMTPHOST}" ] ; then
        echo "Error: missing SMTPHOST in config file" 1>&2
        rc=1
    fi
    if [ -z "${SMTPUSER}" ] ; then
        echo "Error: missing SMTPUSER in config file" 1>&2
        rc=1
    fi
    if [ -z "${SMTPPW}" ] ; then
        echo "Error: missing SMTPPW in config file" 1>&2
        rc=1
    fi
    if [ -z "${TINDER_NAME}" ] ; then
        echo "Error: missing TINDER_NAME in config file" 1>&2
        rc=1
    fi
    if [ -z "${OWNER}" ] ; then
        echo "Error: missing OWNER in config file" 1>&2
        rc=1
    fi
    if [ "$rc" != "0" ] ; then
        exit 1
    fi

	echo "test email from tinbuild" | ${BIN_DIR?}/sendEmail -f "$OWNER" -s "${SMTPHOST?}" -xu "${SMTPUSER?}" -xp "${SMTPPW?}" -t "$OWNER"  -u "tinderbuild test" || (echo "Errot sending test email" 1>&2 ; exit 1)

    echo "Sanity checks OK."
    exit 0
}



#
# Main
#

while getopts cehinm:p:rvw:z opt ; do
    case "$opt" in
        e) LOCK=0 ;;      # whether to use flock to protect the build-cycle
        c) CHECK=1 ;;     # whether to invoke the sanity-check function
        h) usage; exit ;; # display help
        i) NICE="$NICE ionice -c3" ;; # be gentle on i/o
        m) SEND_MAIL="$OPTARG" ;; # which email to wend and to whom
        n) NICE="$NICE nice" ;;   # build 'nicely' :-)
        p) PROFILE_NAME="$OPTARG" ;; # profile to use to deterine extra parameter (email mostly) and autogen arguments
        r) PUSH_NIGHTLIES=1 ; BANDWIDTH="$OPTARG" ;; # whether to upload daily build.
        v) V=1 ;;         # print more messages
        w) PAUSE_SECONDS="$OPTARG" ;; # cool-down time after a build, in seconds
        z) PRIME_BUILD=1 ;;           # to run an initial build (without sending any email) to establish a 'baseline'
        ?) usage; exit ;;
    esac
done

if [ "$CHECK" = "1" ] ; then
    sanity_check
fi

load_profile "$PROFILE_NAME"

# if we want email to be sent, we must make sure that the required parameters are set in the profile (or in the environment)
case "$SEND_MAIL" in
    all|tb|owner|debug)
        if [ -n "${SEND_MAIL}" ] ; then
            rc=0
            if [ -z "${SMTPHOST}" ] ; then
                echo "Error: missing SMTPHOST" 1>&2
                rc=1
            fi
            if [ -z "${SMTPUSER}" ] ; then
                echo "Error: missing SMTPUSER" 1>&2
                rc=1
            fi
            if [ -z "${SMTPPW}" ] ; then
                echo "Error: missing SMTPPW" 1>&2
                rc=1
            fi
            if [ -z "${TINDER_NAME}" ] ; then
                echo "Error: missing TINDER_NAME" 1>&2
                rc=1
            fi
            if [ -z "${OWNER}" ] ; then
                echo "Error: missing OWNER" 1>&2
                rc=1
            fi
            if [ "$rc" != "0" ] ; then
                exit 1
            fi
        fi
        ;;
    none)
        SEND_MAIL=""
        ;;
    *)
        echo "Invalid -m argument:$SEND_MAIL" 1>&2
        exit 1
        ;;
esac


# where to report
# right now we are limited to local branch that match what the tinderbox server expect
#
B=`git branch | grep '^\*' | sed 's/^..//'`
TINDER_BRANCH=
case "$B" in
    master) TINDER_BRANCH='MASTER' ;;
    libreoffice-3-4) TINDER_BRANCH=$B ;;
    *) echo "Unknown, non-registered branch, please update tinbuild, and tinderbox.libreoffice.org."2>&1 ; exit 1 ;;
esac

collect_current_heads

# do a build without involving the tinderbox to establish a good baseline
if [ "${PRIME_BUILD?}" = "1" ] ; then
    SEND_MAIL=""  # we don't want to notify the tinderbox
    log_msgs "Starting primer for branch '$TINDER_BRANCH'."
    (
        do_flock -x 200

        do_build

        rotate_logs

        exit ${retval?}
    ) 200>${lock_file?}
    retval=$?

    exit ${retval?}
else
    if [ ! -f "tb_${B}_last-success-git-heads.txt" ] ; then
        echo "You need a valid baseline. run once with -z or make sure you have a valid tb_${B}_last-success-git-heads.txt" 1>&2
        exit 1;
    else
        # reset to at the last sucessfull build
        retval=0
        cp tb_${B}_last-success-git-heads.txt tb_${B}_current-git-heads.log
        cp tb_${B}_last-success-git-timestamp.txt tb_${B}_current-git-timestamp.log
        rotate_logs
    fi
fi

# main tinderbox loop
while true; do

    wait_for_commits
    last_checkout_date="$(cat tb_${B}_current-git-timestamp.log)"
    (
        do_flock -x 200

        do_build

        rotate_logs

        exit ${retval?}
    ) 200>${lock_file?}



    log_msgs "Waiting ${PAUSE_SECOND?} seconds."
	sleep ${PAUSE_SECOND?}

done
